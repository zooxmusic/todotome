buildscript {
    /*ext {
        springBootVersion = '1.5.10.RELEASE'
    }*/
    repositories {
        jcenter()
    }

    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        classpath("se.transmode.gradle:gradle-docker:1.2")
        classpath "com.avast.gradle:gradle-docker-compose-plugin:0.6.12"
        classpath("io.spring.gradle:dependency-management-plugin:1.0.4.RELEASE")
        classpath 'ru.vyarus:gradle-quality-plugin:2.4.0'

    }
}

apply plugin: 'docker-compose'

allprojects {
    apply plugin: 'java'
    //apply plugin: 'io.spring.dependency-management'
    apply plugin: 'org.springframework.boot'
    apply plugin: "io.spring.dependency-management"
    apply plugin: 'docker'
    //apply plugin: 'ru.vyarus.quality'

    group = 'com.todotome'

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    repositories {
        jcenter()
    }

    dependencies {
        compile(
                ["org.springframework.boot:spring-boot-starter-web"],
                ["org.springframework.boot:spring-boot-starter-actuator"],
                //["org.springframework.cloud:spring-cloud-stream"],
                ["io.springfox:springfox-swagger2:${swaggerVersion}"],
                ["io.springfox:springfox-swagger-ui:${swaggerVersion}"]
        )
        //runtime fileTree(dir: 'libs', include: '*.jar')
        testCompile(
                ["junit:junit"],
                ["org.springframework.boot:spring-boot-starter-test"]
        )
    }

    dependencyManagement {
        imports {
            mavenBom("org.springframework.boot:spring-boot-dependencies:${springBootVersion}")
            mavenBom("org.springframework.cloud:spring-cloud-dependencies:Camden.SR7")
            mavenBom("io.spring.platform:platform-bom:Brussels-SR6")

        }
    }

    task buildDocker(type: Docker, dependsOn: build) {
        push = true
        applicationName = jar.baseName
        dockerfile = file('deploy/Dockerfile')
        doFirst {
            copy {
                from jar
                into stageDir
            }
            copy {
                from "${project.buildDir}/resources/main/run.sh"
                into stageDir
            }
        }
    }



}
dockerCompose {
    useComposeFiles = ['deploy/docker-compose.yml']
    // useComposeFiles = ['docker-compose.yml', 'docker-compose.prod.yml'] // like 'docker-compose -f <file>'; default is empty
    // startedServices = ['web'] // list of services to execute when calling 'docker-compose up' or 'docker-compose pull' (when not specified, all services are executed)
    // scale = [${serviceName1}: 5, ${serviceName2}: 2] // Pass docker compose --scale option like 'docker-compose up --scale serviceName1=5 --scale serviceName2=2'
    // forceRecreate = false // pass '--force-recreate' when calling 'docker-compose up' when set to 'true`
    // ignorePullFailure = false // when set to true, pass '--ignore-pull-failure' to 'docker-compose pull'
    // upAdditionalArgs = ['--no-deps']

    // waitForTcpPorts = true // turns off the waiting for exposed TCP ports opening
    // captureContainersOutput = false // if true, prints output of all containers to Gradle output - very useful for debugging; default is false
    // captureContainersOutputToFile = '/path/to/logFile' // sends output of all containers to a log file

    // stopContainers = true // doesn't call `docker-compose down` - useful for debugging
    // removeContainers = true
    // removeImages = "None" // Other accepted values are: "All" and "Local"
    // removeVolumes = true
    // removeOrphans = false // removes containers for services not defined in the Compose file

    // projectName = 'my-project' // allow to set custom docker-compose project name (defaults to directory name)
    // executable = '/path/to/docker-compose' // allow to set the path of the docker-compose executable (useful if not present in PATH)
    // dockerExecutable = '/path/to/docker' // allow to set the path of the docker executable (useful if not present in PATH)
    // dockerComposeWorkingDirectory = '/path/where/docker-compose/is/invoked/from'
    // dockerComposeStopTimeout = java.time.Duration.ofSeconds(20) // time before docker-compose sends SIGTERM to the running containers after the composeDown task has been started
    // environment.put 'BACKEND_ADDRESS', '192.168.1.100' // Pass environment variable to 'docker-compose' for substitution in compose file
}
/*
test.doFirst {
    // exposes "${serviceName}_HOST" and "${serviceName}_TCP_${exposedPort}" environment variables
    // for example exposes "WEB_HOST" and "WEB_TCP_80" environment variables for service named `web` with exposed port `80`
    // if service is scaled using scale option, environment variables will be exposed for each service instance like "WEB_1_HOST", "WEB_1_TCP_80", "WEB_2_HOST", "WEB_2_TCP_80" and so on
    dockerCompose.exposeAsEnvironment(test)
    // exposes "${serviceName}.host" and "${serviceName}.tcp.${exposedPort}" system properties
    // for example exposes "web.host" and "web.tcp.80" system properties for service named `web` with exposed port `80`
    // if service is scaled using scale option, environment variables will be exposed for each service instance like "web_1.host", "web_1.tcp.80", "web_2.host", "web_2.tcp.80" and so on
    dockerCompose.exposeAsSystemProperties(test)
    // get information about container of service `web` (declared in docker-compose.yml)
    def webInfo = dockerCompose.servicesInfos.web.firstContainer
    // in case scale option is used, dockerCompose.servicesInfos.containerInfos will contain information about all running containers of service. Particular container can be retrieved either by iterating the values of containerInfos map (key is service instance name, for example 'web_1')
    def webInfo = dockerCompose.servicesInfos.web.'web_1'
    // pass host and exposed TCP port 80 as custom-named Java System properties
    systemProperty 'myweb.host', webInfo.host
    systemProperty 'myweb.port', webInfo.ports[80]
}*/